
'''
Gramática para uma linguagem simples.

'''

'''
1. Especificação da Gramática Atual
'''
'''Primeiro, temos as seguintes regras gramaticais:'''

Start → stmt $
Stmt → id assign E
Stmt → if lparen E rparen Stmt else Stmt fi
Stmt → if lparen E rparen Stmt fi
Stmt → while lparen E rparen do Stmt od
Stmt → begin Stmts end
Stmts → Stmts semi Stmt
Stmts → Stmt
E → E plus T
E → T
T → id
T → num



'''Regras de Declaração e Expressão Lógica:'''

Dccl → int id | float id;
Assign → id = expr;
Expr → Expr logic | Expr A;
Expr logic → ! Expr logic
Expr logic → Expr logic AND Expr logic
Expr logic → Expr logic OR Expr logic
Expr logic → (Expr logic)
Expr logic → Expr A OR Expr A



'''2. Identificação de Recursão à Esquerda'''

'''A recursão à esquerda ocorre quando uma produção de uma gramática tem uma regra onde o lado direito começa com o próprio não terminal do lado esquerdo. Neste caso, identificamos as seguintes regras com recursão à esquerda:'''

E → E plus T
Expr → Expr logic | Expr A
Expr logic → Expr logic AND Expr logic
Expr logic → Expr logic OR Expr logic


'''3. Eliminação da Recursão à Esquerda'''

Para E → E plus T | T

'''Identificamos a recursão à esquerda: E → E plus T'''
'''Criamos uma nova regra substituta E':'''

E → T E'
E' → plus T E' | ε
Para Expr → Expr logic | Expr A

'''Identificamos a recursão à esquerda: Expr → Expr logic
Criamos uma nova regra substituta Expr':'''

Expr → Expr A Expr'
Expr' → logic Expr' | ε

Para Expr logic → Expr logic AND Expr logic | Expr logic OR Expr logic | ! Expr logic | (Expr logic)

Identificamos a recursão à esquerda: Expr logic → Expr logic AND Expr logic e Expr logic → Expr logic OR Expr logic

Criamos uma nova regra substituta Expr logic':
Expr logic → ! Expr logic | (Expr logic) Expr logic'
Expr logic' → AND Expr logic Expr logic' | OR Expr logic Expr logic' | ε

'''Gramática Ajustada Sem Recursão à Esquerda'''

Regras Ajustadas:
Start → Stmt $
Stmt → id assign E | if lparen E rparen Stmt else Stmt fi | if lparen E rparen Stmt fi | while lparen E rparen do Stmt od | begin Stmts end
Stmts → Stmts semi Stmt | Stmt
E → T E'
E' → plus T E' | ε
T → id | num
Expr → Expr A Expr'
Expr' → logic Expr' | ε
Expr logic → ! Expr logic | (Expr logic) Expr logic'
Expr logic' → AND Expr logic Expr logic' | OR Expr logic Expr logic' | ε
Dccl → int id | float id;
Assign → id = expr;


**********************************************************************************************************
Para resolver o problema, siga estes passos:
Definição do Token LOGIC:

Certifique-se de que o token 'LOGIC' está definido corretamente no seu analisador léxico. Se não, você deve adicioná-lo.
Caso 'LOGIC' seja uma regra gramatical, deve ser implementada como uma regra no arquivo grammar.py.
Verificação das Regras Definidas:

Verifique se as regras definidas (dccl, assign, expr, expr_A, expr_prime, expr_logic, expr_logic_prime) estão sendo usadas corretamente e se são necessárias na gramática.
Se elas não forem necessárias, considere removê-las. Se forem, certifique-se de que há produções que as utilizam.
Atualização do Arquivo grammar.py:

Adicione a definição para o token 'LOGIC' ou qualquer outra regra que esteja faltando.
Garanta que todas as regras gramaticais necessárias estejam corretamente definidas e utilizáveis.
Exemplo de Atualização do Arquivo grammar.py:
Supondo que 'LOGIC' seja um token que representa operadores lógicos, você pode defini-lo da seguinte forma:









import ply.lex as lex
import ply.yacc as yacc

# Definição dos tokens
tokens = (
    'LOGIC',
    # outros tokens...
)

# Expressão regular para o token LOGIC
t_LOGIC = r'and|or|not'

# Definição das regras da gramática
def p_expr_logic(p):
    '''expr_logic : expr LOGIC expr'''
    p[0] = ('logic', p[1], p[2], p[3])

# Outras regras...

# Construção do parser
parser = yacc.yacc()

if __name__ == '__main__':
    G = Grammar()
    G.grammar('S')
    G.add_nonterminal('A')
    G.add_nonterminal('B')
    G.add_terminal('a')
    G.add_terminal('b')
    G.add_terminal('c')
    G.add_production('S', ['A', 'B', 'c'])
    G.add_production('A', ['a'])
    G.add_production('A', ['c'])
    G.add_production('A', [])
    G.add_production('B', 'b')
    G.add_production('B', 'c')
    G.add_production('B', [])
    # Seu código para manipular a gramática...


Isso deve corrigir o problema, eliminando o erro relacionado ao token não definido e os avisos sobre regras não utilizadas. Se ainda houver avisos sobre regras não utilizadas, verifique se todas as regras definidas são realmente necessárias para a análise da gramática.




Regras da Gramática:

Regra 0:  𝑆 ′  → início
Regra 1: início → sentença
Regra 2: sentença → ID ATRIBUIR E
Regra 3: sentença → SE (E) sentença SENÃO sentença FIM_SE
Regra 4: sentença → SE  E  sentença FIM_SE
Regra 5: sentença → ENQUANTO  E  FAÇA sentença FIM_ENQUANTO
Regra 6: sentença → INÍCIO sentenças FIM
Regra 7: sentenças → sentenças PONTO_VÍRGULA sentença
Regra 8: sentenças → sentença
Regra 9: E → T E_prime
Regra 10: E_prime → MAIS T E_prime
Regra 11: E_prime → vazio
Regra 12: T → ID
Regra 13: T → NUM
Regra 14: expr → expr_A expr_prime
Regra 15: expr_prime → LÓGICO expr_prime
Regra 16: expr_prime → vazio
Regra 17: expr_A → T
Regra 18: expr_lógica → NÃO expr_lógica
Regra 19: expr_lógica → expr_lógica expr_lógica_prime
Regra 20: expr_lógica → T expr_lógica_prime
Regra 21: expr_lógica_prime → E expr_lógica expr_lógica_prime
Regra 22: expr_lógica_prime → OU expr_lógica expr_lógica_prime
Regra 23: expr_lógica_prime → vazio
Regra 24: vazio → <vazio>
Regra 25: declaracao → INTEIRO ID
Regra 26: declaracao → REAL ID
Regra 27: atribuicao → ID ATRIBUIR  exp


Terminais (símbolos terminais), com as regras em que aparecem:
E → 21
ATRIBUIR → 2 27
INÍCIO → 6
FAÇA → 5
SENÃO → 3
FIM → 6
FIM_SE → 3 4
REAL → 26
ID → 2 12 25 26 27
SE → 3 4
INTEIRO → 25
( → 3 4 5 19
NÃO → 18
NUM → 13
FIM_ENQUANTO → 5
OU → 22
MAIS → 10
) → 3 4 5 19
PONTO_VÍRGULA → 7
ENQUANTO → 5
erro →
Não terminais (símbolos não terminais), com as regras em que aparecem:

E → 2 3 4 5
E_prime → 9 10
LÓGICO → 15
T → 9 10 17 20
atribuicao →
declaracao →
vazio → 11 16 23
expr → 27
expr_A → 14
expr_lógica → 18 19 21 22
expr_lógica_prime → 19 20 21 22
expr_prime → 14 15   // Modificação de uma regra anterior
início → 0
sentença → 1 3 3 4 5 7 8
sentenças → 6 7

