
'''
Gram√°tica para uma linguagem simples.

'''

'''
1. Especifica√ß√£o da Gram√°tica Atual
'''
'''Primeiro, temos as seguintes regras gramaticais:'''

Start ‚Üí stmt $
Stmt ‚Üí id assign E
Stmt ‚Üí if lparen E rparen Stmt else Stmt fi
Stmt ‚Üí if lparen E rparen Stmt fi
Stmt ‚Üí while lparen E rparen do Stmt od
Stmt ‚Üí begin Stmts end
Stmts ‚Üí Stmts semi Stmt
Stmts ‚Üí Stmt
E ‚Üí E plus T
E ‚Üí T
T ‚Üí id
T ‚Üí num



'''Regras de Declara√ß√£o e Express√£o L√≥gica:'''

Dccl ‚Üí int id | float id;
Assign ‚Üí id = expr;
Expr ‚Üí Expr logic | Expr A;
Expr logic ‚Üí ! Expr logic
Expr logic ‚Üí Expr logic AND Expr logic
Expr logic ‚Üí Expr logic OR Expr logic
Expr logic ‚Üí (Expr logic)
Expr logic ‚Üí Expr A OR Expr A



'''2. Identifica√ß√£o de Recurs√£o √† Esquerda'''

'''A recurs√£o √† esquerda ocorre quando uma produ√ß√£o de uma gram√°tica tem uma regra onde o lado direito come√ßa com o pr√≥prio n√£o terminal do lado esquerdo. Neste caso, identificamos as seguintes regras com recurs√£o √† esquerda:'''

E ‚Üí E plus T
Expr ‚Üí Expr logic | Expr A
Expr logic ‚Üí Expr logic AND Expr logic
Expr logic ‚Üí Expr logic OR Expr logic


'''3. Elimina√ß√£o da Recurs√£o √† Esquerda'''

Para E ‚Üí E plus T | T

'''Identificamos a recurs√£o √† esquerda: E ‚Üí E plus T'''
'''Criamos uma nova regra substituta E':'''

E ‚Üí T E'
E' ‚Üí plus T E' | Œµ
Para Expr ‚Üí Expr logic | Expr A

'''Identificamos a recurs√£o √† esquerda: Expr ‚Üí Expr logic
Criamos uma nova regra substituta Expr':'''

Expr ‚Üí Expr A Expr'
Expr' ‚Üí logic Expr' | Œµ

Para Expr logic ‚Üí Expr logic AND Expr logic | Expr logic OR Expr logic | ! Expr logic | (Expr logic)

Identificamos a recurs√£o √† esquerda: Expr logic ‚Üí Expr logic AND Expr logic e Expr logic ‚Üí Expr logic OR Expr logic

Criamos uma nova regra substituta Expr logic':
Expr logic ‚Üí ! Expr logic | (Expr logic) Expr logic'
Expr logic' ‚Üí AND Expr logic Expr logic' | OR Expr logic Expr logic' | Œµ

'''Gram√°tica Ajustada Sem Recurs√£o √† Esquerda'''

Regras Ajustadas:
Start ‚Üí Stmt $
Stmt ‚Üí id assign E | if lparen E rparen Stmt else Stmt fi | if lparen E rparen Stmt fi | while lparen E rparen do Stmt od | begin Stmts end
Stmts ‚Üí Stmts semi Stmt | Stmt
E ‚Üí T E'
E' ‚Üí plus T E' | Œµ
T ‚Üí id | num
Expr ‚Üí Expr A Expr'
Expr' ‚Üí logic Expr' | Œµ
Expr logic ‚Üí ! Expr logic | (Expr logic) Expr logic'
Expr logic' ‚Üí AND Expr logic Expr logic' | OR Expr logic Expr logic' | Œµ
Dccl ‚Üí int id | float id;
Assign ‚Üí id = expr;


**********************************************************************************************************
Para resolver o problema, siga estes passos:
Defini√ß√£o do Token LOGIC:

Certifique-se de que o token 'LOGIC' est√° definido corretamente no seu analisador l√©xico. Se n√£o, voc√™ deve adicion√°-lo.
Caso 'LOGIC' seja uma regra gramatical, deve ser implementada como uma regra no arquivo grammar.py.
Verifica√ß√£o das Regras Definidas:

Verifique se as regras definidas (dccl, assign, expr, expr_A, expr_prime, expr_logic, expr_logic_prime) est√£o sendo usadas corretamente e se s√£o necess√°rias na gram√°tica.
Se elas n√£o forem necess√°rias, considere remov√™-las. Se forem, certifique-se de que h√° produ√ß√µes que as utilizam.
Atualiza√ß√£o do Arquivo grammar.py:

Adicione a defini√ß√£o para o token 'LOGIC' ou qualquer outra regra que esteja faltando.
Garanta que todas as regras gramaticais necess√°rias estejam corretamente definidas e utiliz√°veis.
Exemplo de Atualiza√ß√£o do Arquivo grammar.py:
Supondo que 'LOGIC' seja um token que representa operadores l√≥gicos, voc√™ pode defini-lo da seguinte forma:









import ply.lex as lex
import ply.yacc as yacc

# Defini√ß√£o dos tokens
tokens = (
    'LOGIC',
    # outros tokens...
)

# Express√£o regular para o token LOGIC
t_LOGIC = r'and|or|not'

# Defini√ß√£o das regras da gram√°tica
def p_expr_logic(p):
    '''expr_logic : expr LOGIC expr'''
    p[0] = ('logic', p[1], p[2], p[3])

# Outras regras...

# Constru√ß√£o do parser
parser = yacc.yacc()

if __name__ == '__main__':
    G = Grammar()
    G.grammar('S')
    G.add_nonterminal('A')
    G.add_nonterminal('B')
    G.add_terminal('a')
    G.add_terminal('b')
    G.add_terminal('c')
    G.add_production('S', ['A', 'B', 'c'])
    G.add_production('A', ['a'])
    G.add_production('A', ['c'])
    G.add_production('A', [])
    G.add_production('B', 'b')
    G.add_production('B', 'c')
    G.add_production('B', [])
    # Seu c√≥digo para manipular a gram√°tica...


Isso deve corrigir o problema, eliminando o erro relacionado ao token n√£o definido e os avisos sobre regras n√£o utilizadas. Se ainda houver avisos sobre regras n√£o utilizadas, verifique se todas as regras definidas s√£o realmente necess√°rias para a an√°lise da gram√°tica.



**************************************************************************************************************
Regras da Gram√°tica:

Regra 0:  ùëÜ ‚Ä≤  ‚Üí in√≠cio
Regra 1: in√≠cio ‚Üí senten√ßa
Regra 2: senten√ßa ‚Üí ID ATRIBUIR E
Regra 3: senten√ßa ‚Üí SE (E) senten√ßa SEN√ÉO senten√ßa FIM_SE
Regra 4: senten√ßa ‚Üí SE  E  senten√ßa FIM_SE
Regra 5: senten√ßa ‚Üí ENQUANTO  E  FA√áA senten√ßa FIM_ENQUANTO
Regra 6: senten√ßa ‚Üí IN√çCIO senten√ßas FIM
Regra 7: senten√ßas ‚Üí senten√ßas PONTO_V√çRGULA senten√ßa
Regra 8: senten√ßas ‚Üí senten√ßa
Regra 9: E ‚Üí T E_prime
Regra 10: E_prime ‚Üí MAIS T E_prime
Regra 11: E_prime ‚Üí vazio
Regra 12: T ‚Üí ID
Regra 13: T ‚Üí NUM
Regra 14: expr ‚Üí expr_A expr_prime
Regra 15: expr_prime ‚Üí L√ìGICO expr_prime
Regra 16: expr_prime ‚Üí vazio
Regra 17: expr_A ‚Üí T
Regra 18: expr_l√≥gica ‚Üí N√ÉO expr_l√≥gica
Regra 19: expr_l√≥gica ‚Üí expr_l√≥gica expr_l√≥gica_prime
Regra 20: expr_l√≥gica ‚Üí T expr_l√≥gica_prime
Regra 21: expr_l√≥gica_prime ‚Üí E expr_l√≥gica expr_l√≥gica_prime
Regra 22: expr_l√≥gica_prime ‚Üí OU expr_l√≥gica expr_l√≥gica_prime
Regra 23: expr_l√≥gica_prime ‚Üí vazio
Regra 24: vazio ‚Üí <vazio>
Regra 25: declaracao ‚Üí INTEIRO ID
Regra 26: declaracao ‚Üí REAL ID
Regra 27: atribuicao ‚Üí ID ATRIBUIR  exp


Terminais (s√≠mbolos terminais), com as regras em que aparecem:
E ‚Üí 21
ATRIBUIR ‚Üí 2 27
IN√çCIO ‚Üí 6
FA√áA ‚Üí 5
SEN√ÉO ‚Üí 3
FIM ‚Üí 6
FIM_SE ‚Üí 3 4
REAL ‚Üí 26
ID ‚Üí 2 12 25 26 27
SE ‚Üí 3 4
INTEIRO ‚Üí 25
( ‚Üí 3 4 5 19
N√ÉO ‚Üí 18
NUM ‚Üí 13
FIM_ENQUANTO ‚Üí 5
OU ‚Üí 22
MAIS ‚Üí 10
) ‚Üí 3 4 5 19
PONTO_V√çRGULA ‚Üí 7
ENQUANTO ‚Üí 5
erro ‚Üí
N√£o terminais (s√≠mbolos n√£o terminais), com as regras em que aparecem:

E ‚Üí 2 3 4 5
E_prime ‚Üí 9 10
L√ìGICO ‚Üí 15
T ‚Üí 9 10 17 20
atribuicao ‚Üí
declaracao ‚Üí
vazio ‚Üí 11 16 23
expr ‚Üí 27
expr_A ‚Üí 14
expr_l√≥gica ‚Üí 18 19 21 22
expr_l√≥gica_prime ‚Üí 19 20 21 22
expr_prime ‚Üí 14 15   //  dModifica√ß√£oe uma regra anterior
in√≠cio ‚Üí 0
senten√ßa ‚Üí 1 3 3 4 5 7 8
senten√ßas ‚Üí 6 7




********************** Lexer.py**********************************************

import ply.lex as lex

# Defini√ß√£o dos tokens
tokens = (
    'ID', 'NUM',
    'ASSIGN', 'PLUS',
    'LPAREN', 'RPAREN',
    'IF', 'ELSE', 'FI',
    'WHILE', 'DO', 'OD',
    'BEGIN', 'END',
    'SEMI',
    'INT', 'FLOAT',
    'AND', 'OR', 'NOT'
)

# Palavras reservadas
reserved = {
    'if': 'IF',
    'else': 'ELSE',
    'fi': 'FI',
    'while': 'WHILE',
    'do': 'DO',
    'od': 'OD',
    'begin': 'BEGIN',
    'end': 'END',
    'int': 'INT',
    'float': 'FLOAT',
    'and': 'AND',
    'or': 'OR',
    'not': 'NOT',
}

# Defini√ß√£o dos tokens
t_ASSIGN = r'='
t_PLUS = r'\+'
t_LPAREN = r'\('
t_RPAREN = r'\)'
t_SEMI = r';'

def t_ID(t):
    r'[a-zA-Z_][a-zA-Z_0-9]*'
    t.type = reserved.get(t.value, 'ID')
    return t

def t_NUM(t):
    r'\d+'
    t.value = int(t.value)
    return t

# Ignorar espa√ßos em branco
t_ignore = ' \t'

# Tratamento de erros
def t_error(t):
    print(f"Illegal character '{t.value[0]}'")
    t.lexer.skip(1)

# Constru√ß√£o do lexer
lexer = lex.lex()



**********************************Grammar.py*************************************************

'''Este arquivo define a gram√°tica e as regras de produ√ß√£o:'''


import ply.yacc as yacc
from lexer import tokens

class Grammar:

    def __init__(self) -> None:
        self.__terminals = {}
        self.__nonterminals = {}
        self.__productions = {}
        self.__id = 0

    def add_terminal(self, x: str) -> int:
        if x in self.__nonterminals:
            raise ValueError()
        self.__terminals[x] = self.__id
        self.__id = self.__id+1
        return self.__terminals[x]

    def add_nonterminal(self, X: str):
        if X in self.__terminals:
            raise ValueError()
        self.__nonterminals[X] = self.__id
        self.__id = self.__id + 1
        return self.__nonterminals[X]

    def grammar(self, S: str) -> None:
        self.add_nonterminal(S)

    def add_production(self, A: str, rhs: list) -> int:
        self.__productions[self.__id] = {'lhs': '', 'rhs': []}
        self.__productions[self.__id]['lhs'] = A
        self.__productions[self.__id]['rhs'] = rhs
        self.__id = self.__id+1
        return self.__id - 1

    def terminals(self) -> iter:
        return iter(self.__terminals)

    def nonterminals(self) -> iter:
        return iter(self.__nonterminals)

    def productions(self) -> iter:
        return iter(self.__productions)

    def is_terminal(self, X: str) -> bool:
        return X in self.__terminals

    def rhs(self, p: int) -> list:
        return self.__productions[p]['rhs']

    def lhs(self, p: int) -> str:
        return self.__productions[p]['lhs']

    def productions_for(self, A: str) -> list:
        l = []
        for k, v in self.__productions.items():
            if v['lhs'] == A:
                l.append(k)
        return l

    def occurrences(self, X: str) -> list:
        l = []
        for k, v in self.__productions.items():
            for i, rhs in enumerate(v['rhs']):
                if rhs == X:
                    l.append((k, i))
        return l

    def production(self, O: tuple[int, int]) -> int:
        return O[0]

    def tail(self, p: int, i: int) -> list:
        return self.__productions[p]['rhs'][i+1:]

# Defini√ß√£o das regras de gram√°tica ajustadas
def p_start(p):
    '''start : stmt'''

def p_stmt(p):
    '''stmt : ID ASSIGN E
            | IF LPAREN E RPAREN stmt ELSE stmt FI
            | IF LPAREN E RPAREN stmt FI
            | WHILE LPAREN E RPAREN DO stmt OD
            | BEGIN stmts END'''

def p_stmts(p):
    '''stmts : stmts SEMI stmt
             | stmt'''

def p_E(p):
    '''E : T E_prime'''

def p_E_prime(p):
    '''E_prime : PLUS T E_prime
               | empty'''

def p_T(p):
    '''T : ID
         | NUM'''

def p_expr(p):
    '''expr : expr_A expr_prime'''

def p_expr_prime(p):
    '''expr_prime : LOGIC expr_prime
                  | empty'''

def p_expr_A(p):
    '''expr_A : T'''

def p_expr_logic(p):
    '''expr_logic : NOT expr_logic
                  | LPAREN expr_logic RPAREN expr_logic_prime
                  | T expr_logic_prime'''

def p_expr_logic_prime(p):
    '''expr_logic_prime : AND expr_logic expr_logic_prime
                        | OR expr_logic expr_logic_prime
                        | empty'''

def p_empty(p):
    '''empty :'''
    pass

# Regras de declara√ß√£o e atribui√ß√£o (ajustadas para uso)
def p_dccl(p):
    '''dccl : INT ID
            | FLOAT ID'''

def p_assign(p):
    '''assign : ID ASSIGN expr'''

# Tratamento de erros de sintaxe
def p_error(p):
    print("Syntax error in input!")

# Constru√ß√£o do parser
parser = yacc.yacc()


*************************************main.py******************************************

from grammar import Grammar

def main():
    # Cria√ß√£o da gram√°tica
    G = Grammar()
    
    # Defini√ß√£o do s√≠mbolo inicial da gram√°tica
    G.grammar('S')
    
    # Adicionando n√£o terminais
    G.add_nonterminal('A')
    G.add_nonterminal('B')
    
    # Adicionando terminais
    G.add_terminal('a')
    G.add_terminal('b')
    G.add_terminal('c')
    
    # Adicionando produ√ß√µes
    G.add_production('S', ['A', 'B', 'c'])
    G.add_production('A', ['a'])
    G.add_production('A', ['c'])
    G.add_production('A', [])
    G.add_production('B', ['b'])
    G.add_production('B', ['c'])
    G.add_production('B', [])
    
    # Exibi√ß√£o das produ√ß√µes adicionadas
    print("Produ√ß√µes:")
    for p_id in G.productions():
        lhs = G.lhs(p_id)
        rhs = G.rhs(p_id)
        print(f"{lhs} -> {' '.join(rhs) if rhs else 'Œµ'}")

if __name__ == '__main__':
    main()




***********************************************************************************************************

Funcionamento da Gram√°tica
Defini√ß√£o da Gram√°tica:

Classe Gram√°tica: Gerencia terminais (tokens), n√£o-terminais (s√≠mbolos) e produ√ß√µes (regras de gram√°tica).
M√©todos Principais:
adicionar_terminal(x): Adiciona um terminal √† gram√°tica.
adicionar_nao_terminal(X): Adiciona um n√£o-terminal √† gram√°tica.
adicionar_produ√ß√£o(A, rhs): Adiciona uma produ√ß√£o, onde A √© o lado esquerdo e rhs √© a lista de s√≠mbolos do lado
direito.
Defini√ß√£o das Regras de Produ√ß√£o:

Regras de Sintaxe (p_): Definem como os tokens e n√£o-terminais se combinam para formar frases v√°lidas. Por exemplo,
stmt pode ser uma atribui√ß√£o, um comando if, ou um loop while.
Analisador (Parser):

Utiliza o ply.yacc para construir um parser que verifica se uma sequ√™ncia de tokens corresponde √†s regras definidas na
gram√°tica.
Lexer:

Utiliza o ply.lex para definir e reconhecer tokens e regras lexicais, como identificadores (ID), n√∫meros (NUM),
e palavras-chave (SE, INICIO, etc.).
Expans√£o e Constru√ß√£o
Para expandir a gram√°tica e continuar a constru√ß√£o do compilador ou analisador sint√°tico, voc√™ pode:

Adicionar Novos Tokens e Regras:

Definir novos tokens no lexer e criar regras correspondentes no parser para lidar com esses tokens.
Implementar Fun√ß√µes de A√ß√£o:

Adicionar fun√ß√µes que executam a√ß√µes quando certas produ√ß√µes s√£o reconhecidas. Isso pode envolver a constru√ß√£o de uma 
√°rvore de sintaxe ou a execu√ß√£o de c√≥digo.
Adicionar Novos N√£o-Terminais e Produ√ß√µes:

Incluir mais n√£o-terminais e suas produ√ß√µes para suportar novas constru√ß√µes da linguagem ou aumentar a expressividade
da gram√°tica.
Tratamento de Erros:

Melhorar a detec√ß√£o e recupera√ß√£o de erros sint√°ticos para fornecer mensagens de erro mais √∫teis e precisas.
Resumo
Esta gram√°tica √© a base para criar um analisador que verifica a sintaxe de um c√≥digo de acordo com regras espec√≠ficas.
Para evoluir, adicione mais tokens, produ√ß√µes e funcionalidades conforme necess√°rio para suportar a linguagem desejada
e construir um compilador completo.


*************************************Especifica√ß√£o da gram√°tica**********************************************

Primeiro passo ser√° criar as especifica√ß√µes da linguagem(a gram√°tica), podemos usar apenas int e float,
depois extruturas condicionais if else, extrutura de repeti√ß√£o, escolher como finalizar essas extruturas, se com
chaves ou end if ou end while.
Sobre as opera√ß√µes b√°sicas +, -, *, e divis√£o, cuidado com a ordem de preced√™ncia.
Esotruturas l√≥gicas definir se pode misturar ou n√£o.
OBS: Lembrando que o nossa gram√°tica t√° adaptada, ou seja um pouco misturada.
Garantir que seja LL1.
Seguindo essas orienta√ß√µes, ficar√° mais f√°cil e a  gera√ß√£o de c√≥digo.
********************************************************************************************************************






